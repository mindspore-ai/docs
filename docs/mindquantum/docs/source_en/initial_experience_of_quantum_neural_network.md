# Initial experience of quantum neural network

<a href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/initial_experience_of_quantum_neural_network.md" target="_blank"><img src="https://gitee.com/mindspore/docs/raw/master/resource/_static/logo_source_en.png"></a>

## Structure of Quantum Neural Network

In MindQuantum, the structure of the Quantum Neural Network (QNN) is shown in the figure below, which usually consists of three parts:

(1) One (or more) encoding circuit(s) for encoding classical data to quantum data (usually called Encoder);

(2) One (or more) training circuit(s) for training parameters in a quantum gate with parameters (usually called Ansatz);

(3) One (or more) measurement(s) for detecting whether the measurement value (for example, the measurement in the Z direction is the projection of the quantum state of a qubit on the Z axis, and the measurement obtains the expected value of the quantum state with respect to the Pauli Z operator (not limited to the Pauli Z operator, it can be replaced by other operators)) is close to the target expected value.

![mindquantum](./images/mindquantum.png)

Below, we use a simple example to experience how to use MindQuantum.

## Simple Example

![example circuit](./images/example_circuit.png)

We build a quantum neural network as shown in the figure above, where the Encoder consists of an `H` gate, an `RX` gate, an `RY` gate and an `RZ` gate, Ansatz consists of an `RX` gate and an `RY` gate, and the measurement is The Pauli `Z` operator acting on the 0th qubit.

Problem description: We regard the Encoder as the error effect of the system on the initial quantum state (the parameters $\alpha_0, \alpha_1$ and $\alpha_2$ are a fixed value obtained by preprocessing the original classical data (optional), that is, the known value, which is set to 0.2, 0.3 and 0.4 here respectively). We need to train an Ansatz to cancel out this error, so that the final quantum state is still in the $|0\rangle$ state.

Idea: Perform the Pauli `Z` operator measurement in the final state, and the measurement value at this time is the expected value of the quantum state at this time about the Pauli `Z` operator. Since $|0\rangle$ is the eigenstate of operator `Z`, and the eigenvalue is 1, it is easy to know $$ \langle 0|Z|0\rangle=1. $$ That is, the target expectation is 1. Whether the state at this time is $|0\rangle$ can be verified by measuring the expected value.

Solution: By training the parameters in the Ansatz, we hope that the measurement value is close to the target expected value. In other words, we only need to make the measurement value as close as possible to the expected value corresponding to the $|0\rangle$ state with respect to the Pauli `Z` operator, then the The state is $|0\rangle$, that is, the Ansatz cancels the error generated by the Encoder on the initial quantum state.

## Environment Preparation

Import the modules that this tutorial depends on.

```python
import numpy as np                            # Import the numpy library and abbreviated as np
from mindquantum.core import Circuit          # Import the Circuit module for building quantum circuits
from mindquantum.core import H, RX, RY, RZ    # Import quantum gates H, RX, RY, RZ
```

## Building Encoder

According to the quantum circuit diagram shown, we can build the Encoder in MindQuantum.

```python
# pylint: disable=W0104
encoder = Circuit()                   # Initialize the quantum circuit
encoder += H.on(0)                    # The H gate acts on the 0th qubit
encoder += RX(f'alpha{0}').on(0)      # The RX(alpha_0) gate acts on the 0th qubit
encoder += RY(f'alpha{1}').on(0)      # The RY(alpha_1) gate acts on the 0th qubit
encoder += RZ(f'alpha{2}').on(0)      # The RZ(alpha_2) gate acts on the 0th qubit
encoder = encoder.no_grad()           # As the first layer of the entire quantum neural network, the Encoder does not need to take the derivative of the gradient in the encoding circuit, so no_grad() is added.
encoder.summary()                     # Print the summary of Encoder
encoder
```

```text
==================Circuit Summary==================
|Total number of gates  : 4.                      |
|Parameter gates        : 3.                      |
|with 3 parameters are  : alpha0, alpha1, alpha2. |
|Number qubit of circuit: 1                       |
===================================================

q0: ──H────RX(alpha0)────RY(alpha1)────RZ(alpha2)──
```

As can be seen from the Summary of Encoder, the quantum circuit consists of 4 quantum gates, of which there are 3 quantum gates with parameters and the parameters are $\alpha_0,\alpha_1,\alpha_2$​​​​, and the number of qubits regulated by the quantum circuit is 1.

Then, we need to assign values to the parameters in the Encoder. Since the parameters $\alpha_0, \alpha_1$ and $\alpha_2$​ in the Encoder are known values of 0.2, 0.3 and 0.4, respectively, the values are assigned direactly on the parameters and the state at this time can be printed.

```python
alpha0, alpha1, alpha2 = 0.2, 0.3, 0.4              # alpha0, alpha1, alpha2 are known fixed values, assigned 0.2, 0.3 and 0.4 respectively
state = encoder.get_qs(pr={'alpha0': alpha0, 'alpha1': alpha1, 'alpha2': alpha2}, ket=True)
print(state)
```

```text
(0.5669903122552596-0.1753906567580312j)¦0⟩
(0.800814626197614+0.08034947292077024j)¦1⟩
```

The above steps are in order to show that MindQuantum can evolve the quantum circuit (if the quantum gate in the quantum circuit has parameters, you need to assign values to the parameters) and obtain the final state after evolution. It can be seen from the above printing that the final state obtained after evolution is a superposition state composed of $|0\rangle$ ​​​and $|1\rangle$, and the corresponding amplitude of each item is the value corresponding to the left side of the above-printed state.

Note:

(1) By calling the `get_qs` function of the quantum circuit, we can obtain the quantum state evolved from the quantum circuit based on the all-zero state.

(2) The `pr` parameter of the `get_qs` represents the parameter value in the variational quantum circuit, and the `ket` represents whether to output the quantum state as a right vector form.

## Building Ansatz

Similarly, we can also build Ansatz in MindQuantum.

```python
# pylint: disable=W0104
ansatz = Circuit()                           # Initialize the quantum circuit
ansatz += RX(f'theta{0}').on(0)              # The RX(theta_0) gate acts on the 0th qubit
ansatz += RY(f'theta{1}').on(0)              # The RY(theta_1) gate acts on the 0th qubit
ansatz                                       # Printing quantum circuits
```

```text
q0: ──RX(theta0)────RY(theta1)──
```

It can be seen from the summary of Ansatz that the quantum circuit consists of 2 quantum gates, of which there are 2 quantum gates with parameters and the parameters are $\theta_0,\theta_1$, and the number of qubits regulated by the quantum circuit is 1.

Then, assigning values to the parameters in Ansatz. Since Ansatz is a quantum circuit that needs to be trained, the parameters $\theta_0$​​ and $\theta_1$​​ in Ansatz can be set randomly, and are usually set to the initial value of 0 by default. We can also print the quantum state at this time, but this is not a necessary step, just to get familiar with the get_qs function again.

```python
theta0, theta1 = 0, 0                        # Assign theta0, theta1 to the initial value 0, 0
state = ansatz.get_qs(pr=dict(zip(ansatz.params_name, [theta0, theta1])), ket=True)
print(state)
```

```text
1¦0⟩
```

As you can see from the above print, the state at this time is $|0\rangle$ ​​and the amplitude is 1. This is because for Ansatz, the default input quantum state is $|0\rangle$​​, and the parameters $\theta_0$​​ and $\theta_1$ are both 0. At this time, the `RX(0)` gate and the `RY(0)` gate are both equivalent to the I gate, so the entire circuit evolution process is $|0\rangle$ ​​passing after $I\cdot I$, then the final output state is of course $|0\rangle$​​​.

Then the complete quantum circuit is Encoder plus Ansatz.

```python
# pylint: disable=W0104
circuit = encoder + ansatz                   # The complete quantum circuit consists of Encoder and Ansatz
circuit
```

```text
q0: ──H────RX(alpha0)────RY(alpha1)────RZ(alpha2)────RX(theta0)────RY(theta1)──
```

From the summary of the complete quantum circuit, it can be seen that the quantum circuit consists of 6 quantum gates, of which there are 5 quantum gates with parameters and the parameters are $\alpha_0,\alpha_1,\alpha_2,\theta_0,\theta_1$​​​, and the number of qubits regulated by the quantum circuit is 1.

## Building Hamiltonian

We perform a Pauli `Z` operator measurement on the 0th qubit to construct the corresponding Hamiltonian.

```python
from mindquantum.core import QubitOperator           # Import the QubitOperator module for constructing the Pauli operator
from mindquantum.core import Hamiltonian             # Import the Hamiltonian module for building the Hamiltonian

ham = Hamiltonian(QubitOperator('Z0', -1))           # Perform the Pauli Z operator measurement on the 0th qubit and set the coefficient to -1 to construct the corresponding Hamiltonian
print(ham)
```

```text
-1 [Z0]
```

As can be seen from the above printing, the Hamiltonian constructed at this time is to perform the Pauli `Z` operator measurement on the 0th qubit, and the coefficient is -1. The reason why the coefficient is set to -1 is that during the training of the quantum neural network, the gradient of the parameters in Ansatz will always decrease, and the measurement value will always decrease. If it finally converges to -1, the corresponding quantum state is $|1\rangle$ instead of $|0\rangle$​, as shown below

$$ \langle 1|Z|1\rangle=-1. $$

What we want is the $|0\rangle$ state. Therefore, set the coefficient to -1, then when the measurement value is -1, the corresponding quantum state is the $|0\rangle$ state, as shown below

$$ \langle 0|(-Z)|0\rangle=-1. $$

Note:

(1) QubitOperator is the sum of operators acting on qubits and is mainly used to construct Pauli operators; the general format is as follows: QubitOperator(term=None, coefficient=1.0);

(2) Hamiltonian is a Hamiltonian wrapper, which is mainly used to construct a Hamiltonian. The general format is as follows: Hamiltonian(QubitOperator('X0 Y2', 0.5)), X0 and Y2 indicate that the Pauli `X` operator acts on the 0th position Qubit, and the Pauli `Y` operator acts on the second qubit with a coefficient of 0.5.

## Generate Variational Quantum Circuit Simulation Operators

For the quantum circuit built above, we can generate a variational quantum circuit simulation operator in MindQuantum to simulate it.

First, for convenience, we name the parameter arrays in Encoder and Ansatz as encoder_names and ansatz_names, respectively.

```python
encoder_names = encoder.params_name                   # An array of all parameters in the Encoder, the system will automatically generate encoder.para_name
ansatz_names = ansatz.params_name                     # An array of all parameters in the Ansatz, the system will automatically generate ansatz.para_name

print('encoder_names = ', encoder.params_name, '\nansatz_names =', ansatz.params_name)
```

```text
encoder_names =  ['alpha0', 'alpha1', 'alpha2']
ansatz_names = ['theta0', 'theta1']
```

As can be seen from the above print, encoder_names is an array composed of all parameters $\alpha_0, \alpha_1, \alpha_2$​ in Encoder, ansatz_names is an array composed of all parameters $\theta_0,\theta_1$ in Ansatz, these two arrays will be used to generate variational quantum circuit simulation operators.

Then, we obtain the operator for the evolution of the variational quantum circuit and the gradient solution by the `Simulator` module.

```python
# Import Simulator module
from mindquantum.simulator import Simulator

# Generate a simulator based on the projectq backend, and set the number of bits of the simulator to the number of bits of the quantum circuit.
sim = Simulator('projectq', circuit.n_qubits)

# Obtain the evolution of the quantum circuit based on the current quantum state of the simulator and the expectation and gradient solution operators
grad_ops = sim.get_expectation_with_grad(ham,
                                         circuit,
                                         encoder_params_name=encoder_names,
                                         ansatz_params_name=ansatz_names)

# An array of three parameters alpha0, alpha1, alpha2 in Encoder,
# Convert its data type to float32 and store it in encoder_data.
# MindQuantum supports batch training with multiple samples. The Encoder array is two dimensions.
# The first dimension is the sample, and the second dimension is the feature (ie parameter)
encoder_data = np.array([[alpha0, alpha1, alpha2]]).astype(np.float32)

# The array composed of theta0 and theta1 parameters in Ansatz, convert its data type to float32,
# And stored in ansatzr_data, Ansatz data has only one dimension, features (ie parameters)
ansatz_data = np.array([theta0, theta1]).astype(np.float32)

# According to the data of the Encoder and Ansatz, output the measurement value of the variable sub-circuit, the derivative of the parameter in the Encoder and the derivative of the parameter in Ansatz
measure_result, encoder_grad, ansatz_grad = grad_ops(encoder_data, ansatz_data)

print('Measurement result: ', measure_result)
print('Gradient of encoder parameters: ', encoder_grad)
print('Gradient of ansatz parameters: ', ansatz_grad)
```

```text
Measurement result:  [[0.29552022+0.j]]
Gradient of encoder parameters:  [[[0.+0.j 0.+0.j 0.+0.j]]]
Gradient of ansatz parameters:  [[[-0.37202556+0.j  0.87992317+0.j]]]
```

As can be seen from the above print, the measurement result (expected value) is 0.29552022, the derivatives of the 3 parameters in the Encoder are 0, 0, 0 (because we set no_grad() to the Encoder), and the derivatives of the 2 parameters in Ansatz are -0.37202555 and -0.87992316.

Here, what is generated by `get_expectation_with_grad` is just an operator, which cannot be trained yet. It can only be trained by putting it in the quantum neural network. By training the parameters in Ansatz, the derivative of the parameters in Ansatz can be kept decreasing and close to 0, so the measurement value will also be close to -1.

Note:

(1) The `get_expectation_with_grad` of the `Simulator` is used to generate a variational quantum circuit to simulate the operator. The general format is as follows:

```python
Simulator.get_expectation_with_grad(ham,
                                    circ_right,
                                    circ_left,
                                    encoder_params_name,
                                    ansatz_params_name,
                                    parallel_worker=1)
```

This function is suitable for computing the following models: $$E=\left<0\right|U^\dagger_l(\theta) H U_r(\theta)\left|0\right>$$ Where `circ_right` is `Ur`, `circ_left` is `Ul`, when not provided, the default is the same circuit as `circ_right`,
`encoder_params_name` specifies which parameters in the entire system belong to the parameters of the encoder. The encoder can map the classical data to the high-order Hilbert space by feature mapping,
`ansatz_params_name` specifies which parameters in the entire system belong to the parameters of the circuit to be trained,
`parallel_worker` specifies the number of parallels. When the classical data to be encoded is a batch, setting this parameter reasonably can improve the calculation efficiency.

(2) MindSpore is a full-scene deep learning framework, aiming to achieve three goals of easy development, efficient execution, and full-scene coverage, provides tensor-differentiable programmability that supports heterogeneous acceleration, supports cloud, server, edge and end multiple hardware platforms.

## Building a quantum neural network

```python
# pylint: disable=W0104
from mindquantum.framework import MQLayer          # Import MQLayer
import mindspore as ms                             # Import mindspore

ms.set_seed(1)                                     # Set the seed for generating random numbers
ms.context.set_context(mode=ms.context.PYNATIVE_MODE, device_target="CPU")

QuantumNet = MQLayer(grad_ops)
QuantumNet
```

```text
MQLayer<
  (evolution): MQOps<1 qubit projectq VQA Operator>
  >
```

As can be seen from the above printing, we have successfully built a quantum machine learning layer, which can seamlessly form a larger machine learning network with other operators in MindSpore.

Note:

(1) The quantum circuit gradient calculation operators in MindQuantum are all under PYNATIVE_MODE, so the operation mode of MindSpore needs to be set.

(2) We can also build the quantum machine learning layer by the following code, but in MindQuantum, the following code has been packaged, so that we can directly use the MQLayer module to build the quantum machine learning layer. For more complex quantum-classical hybrid neural networks, the following construction will demonstrate its advantages.

```python
class MQLayer(nn.Cell):
    def __init__(self, expectation_with_grad, weight='normal'):
        super(MQLayer, self).__init__()
        self.evolution = MQOps(expectation_with_grad)
        weight_size = len(
            self.evolution.expectation_with_grad.ansatz_params_name)
        self.weight = Parameter(initializer(weight,
                                            weight_size,
                                            dtype=ms.float32),
                                name='ansatz_weight')

    def construct(self, x):
        return self.evolution(x, self.weight)
```

## Training

We use the Adam optimizer to optimize the parameters in Ansatz.

```python
from mindspore.nn import Adam, TrainOneStepCell                   # Import Adam module and TrainOneStepCell module

opti = Adam(QuantumNet.trainable_params(), learning_rate=0.5)     # What needs to be optimized is the trainable parameters in Quantumnet, and the learning rate is set to 0.5
net = TrainOneStepCell(QuantumNet, opti)

for i in range(200):
    res = net(ms.Tensor(encoder_data))
    if i % 10 == 0:
        print(i, ': ', res)
```

```text
0 :  [[0.2837115]]
10 :  [[-0.8851233]]
20 :  [[-0.97001773]]
30 :  [[-0.9929431]]
40 :  [[-0.9939507]]
50 :  [[-0.9967015]]
60 :  [[-0.99878186]]
70 :  [[-0.9995535]]
80 :  [[-0.9999011]]
90 :  [[-0.99998033]]
100 :  [[-0.9999989]]
110 :  [[-0.99999785]]
120 :  [[-0.999997]]
130 :  [[-0.9999987]]
140 :  [[-0.9999998]]
150 :  [[-1.]]
160 :  [[-0.99999994]]
170 :  [[-1.]]
180 :  [[-1.]]
190 :  [[-1.]]
```

As you can see from the above print, finally the measured value converges to -1.

Note:

(1) The Adam module updates the gradient by the adaptive moment estimation algorithm, which can optimize the parameters in Ansazt, and the input is the trainable parameters in the neural network; the general format is as follows: nn.Adam(net.trainable_params(), learning_rate=0.5) ;

(2) The TrainOneStepCell module is a network training package class that wraps the network with an optimizer. The resulting cells are trained with the input "inputs", an inverse graph will be generated in the constructor to update the parameters, and there are different parallel modes available for training. The general format is as follows: nn.TrainOneStepCell(network, optimizer, sens=1.0).

## Result Presentation

Since the measurements have converged to -1, we can print the parameters in Ansatz at this time.

```python
theta0, theta1 = QuantumNet.weight.asnumpy()

print(QuantumNet.weight.asnumpy())
```

```text
[ 2.2420275 -1.0756909]
```

As can be seen from the above printing, the parameters $\theta_1$ and $\theta_2$ in Ansatz at this time are 2.2420275 and -1.0756909 respectively.

By `get_qs`, the quantum state of the quantum circuit at the optimal parameters can be output.

```python
pr = {'alpha0': alpha0, 'alpha1': alpha1, 'alpha2': alpha2, 'theta0': theta0, 'theta1': theta1}
state = circuit.get_qs(pr=pr, ket=True)

print(state)
```

```text
(0.37129760050057437-0.9285139157007681j)¦0⟩
(1.4564552975271372e-05+6.455516706194153e-07j)¦1⟩
```

As can be seen from the above printing, this is the quantum state of the quantum circuit at the optimal parameters. As can be seen from its numerical representation, this is a state close to the target state $|0\rangle$. Finally, we calculate the fidelity of this quantum state to the target state $|0\rangle$ (to verify how similar the two quantum states are), and print the fidelity.

```python
state = circuit.get_qs(pr=pr)
fid = np.abs(np.vdot(state, [1, 0]))**2            # Fidelity is the modulus square of the absolute value of the vector inner product, that is, the modulus square of the inner product of the vector corresponding to the quantum state and the vector [1,0] corresponding to the |0> state at this time is calculated.

print(fid)
```

```text
0.9999999997874571
```

It can be seen that the fidelity at this time is 100.00%, that is to say, the similarity between this state and the target state $|0\rangle$ is 100.00%.

To sum up, we built a simple quantum neural network. By training the parameters in Ansatz, the error generated by the Encoder on the initial quantum state was offset, so that the final quantum state was still $|0\rangle$, and the fidelity reached 100.00%.

So far, we have completed the first experience of quantum neural network by MindQuantum! Hurry up and experience the fun of quantum programming!

To find out more about MindQuantum's API, please click: https://mindspore.cn/mindquantum/
