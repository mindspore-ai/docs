# Grover search algorithm based on MindQuantum

Translator: [unseenme](https://gitee.com/unseenme)

<a href="https://gitee.com/mindspore/docs/blob/master/docs/mindquantum/docs/source_en/grover_search_algorithm.md" target="_blank"><img src="https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/website-images/master/resource/_static/logo_source_en.png"></a>

## Overview

If you have heard of quantum computing, you must have heard of the Grover search algorithm. In 1996, Lov Grover [1] proposed the Grover search algorithm, which is an algorithm that uses the superposition of quantum states to perform parallel computing and achieve acceleration. The Grover search algorithm is recognized as the second large quantum algorithm after Shor algorithm, and it is also the first quantum algorithm to be fully experimentally implemented, which solves the problem of unordered database search. In 1997, Bennett [2] et al. proved that for the unstructured quantum search problem, at least $\Omega(\sqrt{N})$ quantum queries are required, so the Grover search algorithm is the optimal algorithm in the asymptotic sense.

The Unordered Database Search problem is to find some elements that meet the requirements from an unordered database with a large number of elements. Since the number of elements in the database is huge and the elements are unordered, it is easy to verify that a given element satisfies the requirements, but conversely, it is not easy to find these elements.

To solve the unordered database search problem (it may be assumed that there is only one target search data), the time complexity required by the classical algorithm is $\mathcal{O}(N)$, while the time complexity required by the Grover search algorithm is only $\mathcal{O}(\sqrt{N})$, compared with the classical algorithm, it has a quadratic speedup, showing the powerful performance of quantum computing. In addition, the amplitude expansion technique used in Grover search algorithm can accelerate many heuristic classical search algorithms, so it has a wide range of applications.

This document will introduce the basic principles of Grover search algorithm, and show how to use MindQuantum to implement the algorithm by two specific small examples.

## Problem description

We need to search in an unordered set of $N$ elements (database). Establish one-to-one correspondence between elements in the database and indexes (integers from $0$ to $N-1$), and we focus on searching the indices of these elements. Consider formulating this search problem as a function $f(x)$ over an input $x$, where $x$ is an integer between $0$ and $N-1$. Then, the function $f$ is defined as:

$$
\begin{equation}
f(x)=\begin{cases}0,x\neq x_{target}\\\\
1,x=x_{target}
\end{cases}
\end{equation}.
$$

Without loss of generality, assuming $N=2^n$​, then in a quantum system, the index is in the quantum state $|0\rangle,|1\rangle,...,|N-1\rangle$ (or $|00...0\rangle,|00...1\rangle,...,|11...1\rangle$), that is, we can use $n$​ qubits to store these indices.

At the same time, it is assumed that the search problem has only one target state $|\omega\rangle$. The goal of Grover search algorithm is to search for $|\omega\rangle$ with great probability.

## Fundamentals of Grover search algorithm

The basic principle of Grover search algorithm: First, a uniform superposition state is generated by the Hadamard gate, and then the Grover iteration (or $G$ operator) is repeatedly called to amplify the probability amplitude of the target item and suppress the probability amplitude of the non-target item (this method is called is the amplitude amplification), and finally the final state is measured, so that the target state $|\omega\rangle$​​ can be obtained with great probability.

The Grover search algorithm mainly includes the following steps:

* Step 1: Database initialization

  Perform the $H^{\otimes n}$​ operation on $|0\rangle^{\otimes n}$, so that the database is initially in a uniform superposition state, that is
$$ |\psi_0\rangle=H^{\otimes n}|0\rangle^{\otimes n}=\frac{1}{\sqrt{N}}\sum_{i=0}^{N-1}|i\rangle. $$

* Step 2: Grover Iteration

  Grover iteration can be further decomposed into four steps:  
  1. Execute the Oracle operator $U_{\omega}$​, and flip the phase of the target state $|\omega \rangle$​​​​​

      In order to distinguish the data to be found from other data, the easiest way is to flip the phase of the target state (add a negative sign). At this time, we need to construct an Oracle operator $U_{\omega}$, which works as follows: $ \begin{equation} U_{\omega}|x\rangle=\begin{cases} &|x\rangle,x\neq \omega&\\\\ -&|x\rangle,x=\omega& \end{cases} \end{equation}. $  
  Since when $x=\omega$​, $f(\omega)=1$​, the effect of $U_{\omega}$ can also be expressed as: $ U_{\omega}|x\rangle=(-1)^{f(x)}|x\rangle, $
  Its matrix expression is $\begin{equation}U_{\omega}=\left[\begin{array}{ccc}     (-1)^{f(0)} & 0           & \dots  & 0            \\\\     0           & (-1)^{f(1)} & \dots  & 0            \\\\     \vdots      & \vdots      & \ddots & \vdots       \\\\     0           & 0           & \dots  & (-1)^{f(N-1)}\end{array}\right]\end{equation}.$
  2. Perform $H^{\otimes n}$ operation

      Perform $H^{\otimes n}$ operation on $n$ qubits.
  3. Execute conditional phase shift operator $P$

      The conditional phase shift operator $P$ can reverse the phase of each state except the $|0\rangle$ ​state, and its effect is as follows:   $\begin{equation}P|x\rangle=\begin{cases}&|0\rangle,x= 0&\\\\-&|x\rangle,x\neq0&\end{cases}\end{equation}.$
  Its matrix expression is $\begin{equation}P = 2(|0\rangle\langle0|)^{\otimes n} - I_n =\left[\begin{array}{ccc}     1      & 0      & \dots  & 0            \\\\     0      & -1     & \dots  & 0            \\\\     \vdots & \vdots & \ddots & \vdots       \\\\     0      & 0      & \dots  & -1\end{array}\right]\end{equation}.$
  4. Perform $H^{\otimes n}$ operation again

      So far, the complete $G$ operator can be expressed as $ G = H^{\otimes n} [2(|0\rangle\langle0|)^{\otimes n} - I_n] H^{\otimes n} U_{\omega}. $
  Note: The number of iterations required for the $G$ operator is r = \left[ \frac{\pi}{4} \sqrt{\frac{N}{M}} \right] \sim O(\sqrt{N}),
  where, M represents the number of target states.

* Step 3: Measurement

  By performing $\{|0\rangle,|1\rangle\}$ basis measurements on the final state, the target state $|\omega \rangle$ can be obtained with great probability.

The complete quantum circuit model of Grover search algorithm is shown below:

![grover algorithm circuit](./images/grover_algorithm_circuit.png)

## Constructing a unitary operator that flips the phase of a qubit

By the above introduction, we found that the most critical part of the Grover search algorithm is that there is a unitary operator that can flip the phase of the qubit, the Oracle operator $U_{\omega}$ can flip the phase of the target state, and the conditional phase shift operator $P$ can flip the phase of every state except $|0\rangle$ state.

Next, we will construct a unitary operator that can flip the phase of a qubit, defined as follows:

```python
def bitphaseflip_operator(phase_inversion_qubit, n_qubits):   # Define a function that flips the phase of a qubit
    s = [1 for i in range(1 << n_qubits)]
    for i in phase_inversion_qubit:
        s[i] = -1
    if s[0] == -1:
        for i in range(len(s)):
            s[i] = -1 * s[i]
    circuit = Circuit()
    length = len(s)
    cz = []
    for i in range(length):
        if s[i] == -1:
            cz.append([])
            current = i
            t = 0
            while current != 0:
                if (current & 1) == 1:
                    cz[-1].append(t)
                t += 1
                current = current >> 1
            for j in range(i + 1, length):
                if i & j == i:
                    s[j] = -1 * s[j]
    for i in cz:
        if i:
            if len(i) > 1:
                circuit += Z.on(i[-1], i[:-1])
            else:
                circuit += Z.on(i[0])

    return circuit
```

Now, the `bitphaseflip_operator()` function can flip the phase of a qubit, and users only need to input the target quantum state and the total number of qubits that need to flip the phase.

As an example, we now generate a uniform superposition of 3 qubits by running the following code:

```python
# pylint: disable=W0104
from mindquantum import Circuit, UN, H, Z
from mindquantum.simulator import Simulator

n_qubits = 3                                 # Set the number of qubits to 3
sim = Simulator('projectq', n_qubits)        # Use the projectq simulator, named sim

circuit = Circuit()                          # Initialize the quantum circuit, named circuit
circuit += UN(H, n_qubits)                   # H-gate operations are performed on each qubit

sim.apply_circuit(circuit)                   # Run the built quantum circuit circuit by the simulator sim

circuit                                      # Print the quantum circuit circuit at this time
```

```text
q0: ──H──

q1: ──H──

q2: ──H──
```

```python
print(sim.get_qs(True))                      # Print the final state after running the quantum circuit circuit in the simulator sim
```

```text
√2/4¦000⟩
√2/4¦001⟩
√2/4¦010⟩
√2/4¦011⟩
√2/4¦100⟩
√2/4¦101⟩
√2/4¦110⟩
√2/4¦111⟩
```

From the running results, we can see the quantum circuit at this time, and a uniform superposition state of 3 qubits has been generated successfully.

Suppose we need to flip the phase of the $|4\rangle$ state, just call the `bitphaseflip_operator()` function we defined and run the following code:

```python
# pylint: disable=W0104
sim.reset()                                                      # Reset the quantum state maintained by the simulator sim so that the initialized quantum state is |000>

phase_inversion_qubit = [4]                                      # Invert the phase of the |4> state
operator = bitphaseflip_operator(phase_inversion_qubit, n_qubits)# Call our defined bitphaseflip_operator() function

circuit += operator                                              # Add the quantum gate required to flip the phase of the |4> state in the quantum circuit circuit

sim.apply_circuit(circuit)                                       # Run the built quantum circuit circuit again by the simulator sim

circuit                                                          # Print the quantum circuit circuit at this time
```

```text
q0: ──H─────────●─────────●──
                │         │
q1: ──H─────────┼────●────●──
                │    │    │
q2: ──H────Z────Z────Z────Z──
```

```python
print(sim.get_qs(True))                                          # Print the final state after running the quantum circuit circuit in the simulator sim
```

```text
√2/4¦000⟩
√2/4¦001⟩
√2/4¦010⟩
√2/4¦011⟩
-√2/4¦100⟩
√2/4¦101⟩
√2/4¦110⟩
√2/4¦111⟩
```

From the running results, we can see that the quantum circuit at this time, and the phase of $|100\rangle$ is flipped to -1, run the following code:

```python
print(int('100', 2))
```

```text
4
```

It can be seen from the running results that the $|100\rangle$ state where the phase is reversed is the $|4\rangle$ state we want the phase to reverse.

Assuming we need to flip the phase of every state except the $|0\rangle$ state, run the following code:

```python
# pylint: disable=W0104
n_qubits = 3                                                     # Set the number of qubits to 3
sim1 = Simulator('projectq', n_qubits)                           # Use the projectq simulator, named sim1

operator1 = bitphaseflip_operator([i for i in range(1, pow(2, n_qubits))], n_qubits) # Call our defined bitphaseflip_operator() function to flip the phase of each state except |0> state, named operator1

circuit1 = Circuit()                                             # Initialize the quantum circuit, named circuit1
circuit1 += UN(H, n_qubits)                                      # H-gate operations are performed on each qubit
circuit1 += operator1                                            # Add the quantum gates required to flip the phase of each state except the |0> state in the quantum circuit circuit1

sim1.apply_circuit(circuit1)                                     # Run the built quantum circuit circuit1 by the simulator sim1

circuit1                                                         # Print the quantum circuit circuit1 at this time
```

```text
q0: ──H────Z────●────●─────────●──
                │    │         │
q1: ──H────Z────Z────┼────●────●──
                     │    │    │
q2: ──H────Z─────────Z────Z────Z──
```

```python
print(sim1.get_qs(True))                                         # Print the final state after running the quantum circuit circuit1 in the simulator sim1
```

```text
√2/4¦000⟩
-√2/4¦001⟩
-√2/4¦010⟩
-√2/4¦011⟩
-√2/4¦100⟩
-√2/4¦101⟩
-√2/4¦110⟩
-√2/4¦111⟩
```

From the running results, we can see the quantum circuit at this time, and we successfully flip the phase of every state except the $|0\rangle$ state.

That is to say, the function bitphaseflip_operator() we define can implement the Oracle operator $U_{\omega}$ and the conditional phase shift operator $P$ in the Grover search algorithm.

## Examples of Grover search algorithm using MindQuantum

### Example 1: $n=3$, $|\omega\rangle=|2\rangle$ (single target)

First, we need to define the $G$ operator and run the following code:

```python
def G(phase_inversion_qubit, n_qubits):           # Define the G operator in Grover search algorithm
    operator = bitphaseflip_operator(phase_inversion_qubit, n_qubits)
    operator += UN(H, n_qubits)
    operator += bitphaseflip_operator([i for i in range(1, pow(2, n_qubits))], n_qubits)
    operator += UN(H, n_qubits)
    return operator
```

Then, we build the corresponding quantum circuit in MindQuantum according to the quantum circuit model of Grover search algorithm:

```python
# pylint: disable=W0104
from numpy import pi, sqrt

n_qubits = 3                                      # Set the number of qubits to 3
phase_inversion_qubit = [2]                       # Set the target state that needs to flip the phase, and flip the phase of the |2> state here

N = 2 ** (n_qubits)                               # Calculate the total number of elements in the database
M = len(phase_inversion_qubit)                    # Calculate the total number of target states

r = int(pi / 4 * sqrt(N / M))                     # Set the number of iterations of the G operator to r

sim2 = Simulator('projectq', n_qubits)            # Use the projectq simulator, named sim2

circuit2 = Circuit()                              # Initialize the quantum circuit, named circuit2
circuit2 += UN(H, n_qubits)                       # H-gate operations are performed on each qubit

for i in range(r):                                # Execute the G operator r times in a loop
    circuit2 += G(phase_inversion_qubit, n_qubits)

sim2.apply_circuit(circuit2)                      # Run the built quantum circuit circuit2 by the simulator sim2

circuit2                                          # Print the quantum circuit circuit2 at this time
```

```text
q0: ──H─────────●─────────●────H────Z────●────●─────────●────H─────────●─────────●────H────Z────●────●─────────●────H──
                │         │              │    │         │              │         │              │    │         │
q1: ──H────Z────Z────●────●────H────Z────Z────┼────●────●────H────Z────Z────●────●────H────Z────Z────┼────●────●────H──
                     │    │                   │    │    │                   │    │                   │    │    │
q2: ──H──────────────Z────Z────H────Z─────────Z────Z────Z────H──────────────Z────Z────H────Z─────────Z────Z────Z────H──
```

```python
print(sim2.get_qs(True))                          # Print the final state after running the quantum circuit circuit2 in the simulator sim2
```

```text
-√2/16¦000⟩
-√2/16¦001⟩
0.9722718241315036¦010⟩
-√2/16¦011⟩
-√2/16¦100⟩
-√2/16¦101⟩
-√2/16¦110⟩
-√2/16¦111⟩
```

From the results of the operation, we can see that the amplitude of the $|010\rangle$ state is 0.9722718241315036, which is a very large amplitude compared to other quantum states, that is to say, if we measure the state at this time, it will be with a great probability get the target state $|010\rangle$, run the following code to measure:

```python
# pylint: disable=W0104
from mindquantum import Measure

sim2.reset()                                      # Reset the quantum state maintained by the simulator sim2, so that the initialized quantum state is |000>

circuit2 += UN(Measure(), circuit2.n_qubits)      # Add a measurement gate to each qubit in the quantum circuit circuit2

result = sim2.sampling(circuit2, shots=1000)      # Sampling the quantum circuit circuit2 1000 times by the simulator sim2
result                                            # print sampling results
```

```text
shots: 1000
Keys: q2 q1 q0│0.00     0.2         0.4         0.6         0.8         1.0
──────────────┼───────────┴───────────┴───────────┴───────────┴───────────┴
           000│▒
              │
           001│▒
              │
           010│▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
              │
           011│▒
              │
           100│▒
              │
           101│▒
              │
           110│▒
              │
           111│▒
              │
{'000': 9, '001': 10, '010': 947, '011': 4, '100': 8, '101': 8, '110': 8, '111': 6}
```

It can be seen from the running results that 947 of the 1000 samples have the sampling result of 010. Convert it to a decimal number and run the following code:

```python
print(int('010', 2))
```

```text
2
```

It can be seen from the running results that we successfully search for the $|2\rangle$ state.

### Example 2: $n=5$, $|\omega\rangle=|5\rangle$ and $|11\rangle$ (multi-target)

In Example 1, single-target search is implemented, and now we try to achieve multi-target search. First, the $G$ operator has been defined. We only need to set the number of qubits and the target state that needs to flip the phase, and then build the corresponding quantum circuit. Run the following code:

```python
# pylint: disable=W0104
n_qubits = 5                                      # Set the number of qubits to 5
phase_inversion_qubit = [5, 11]                   # Set the target state to be phase-flipped, and flip the phases of the |5> state and |11> state here

N = 2 ** (n_qubits)                               # Calculate the total number of elements in the database
M = len(phase_inversion_qubit)                    # Calculate the total number of target states

r = int(pi / 4 * sqrt(N / M))                     # Set the number of iterations of the G operator to r

sim3 = Simulator('projectq', n_qubits)            # Use the projectq simulator, named sim3

circuit3 = Circuit()                              # Initialize the quantum circuit, named circuit3
circuit3 += UN(H, n_qubits)                       # H-gate operations are performed on each qubit

for i in range(r):                                # Execute the G operator r times in a loop
    circuit3 += G(phase_inversion_qubit, n_qubits)

sim3.apply_circuit(circuit3)                      # Run the built quantum circuit circuit3 by the simulator sim3

circuit3                                          # Print the quantum circuit circuit3 at this time
```

```text
q0: ──H────●────●────●────●────●────●────●────●────H────Z────●────●─────────●────●─────────●─────────●─────────●────●─────────●─────────●─────────●─────────●─────────●─────────●─────────●────H────●────●────●────●────●────●────●────●────H────Z────●────●─────────●────●─────────●─────────●─────────●────●─────────●─────────●─────────●─────────●─────────●─────────●─────────●────H────●────●────●────●────●────●────●────●────H────Z────●────●─────────●────●─────────●─────────●─────────●────●─────────●─────────●─────────●─────────●─────────●─────────●─────────●────H──
           │    │    │    │    │    │    │    │              │    │         │    │         │         │         │    │         │         │         │         │         │         │         │         │    │    │    │    │    │    │    │              │    │         │    │         │         │         │    │         │         │         │         │         │         │         │         │    │    │    │    │    │    │    │              │    │         │    │         │         │         │    │         │         │         │         │         │         │         │
q1: ──H────┼────●────●────┼────┼────●────●────┼────H────Z────Z────┼────●────●────┼────●────●─────────┼────●────●────┼────●────●─────────┼────●────●─────────┼────●────●─────────┼────●────●────H────┼────●────●────┼────┼────●────●────┼────H────Z────Z────┼────●────●────┼────●────●─────────┼────●────●────┼────●────●─────────┼────●────●─────────┼────●────●─────────┼────●────●────H────┼────●────●────┼────┼────●────●────┼────H────Z────Z────┼────●────●────┼────●────●─────────┼────●────●────┼────●────●─────────┼────●────●─────────┼────●────●─────────┼────●────●────H──
           │    │    │    │    │    │    │    │                   │    │    │    │    │    │         │    │    │    │    │    │         │    │    │         │    │    │         │    │    │         │    │    │    │    │    │    │    │                   │    │    │    │    │    │         │    │    │    │    │    │         │    │    │         │    │    │         │    │    │         │    │    │    │    │    │    │    │                   │    │    │    │    │    │         │    │    │    │    │    │         │    │    │         │    │    │         │    │    │
q2: ──H────Z────Z────┼────●────●────●────┼────●────H────Z─────────Z────Z────Z────┼────┼────┼────●────●────●────●────┼────┼────┼────●────●────●────●─────────┼────┼────┼────●────●────●────●────H────Z────Z────┼────●────●────●────┼────●────H────Z─────────Z────Z────Z────┼────┼────┼────●────●────●────●────┼────┼────┼────●────●────●────●─────────┼────┼────┼────●────●────●────●────H────Z────Z────┼────●────●────●────┼────●────H────Z─────────Z────Z────Z────┼────┼────┼────●────●────●────●────┼────┼────┼────●────●────●────●─────────┼────┼────┼────●────●────●────●────H──
                     │    │    │    │    │    │                                  │    │    │    │    │    │    │    │    │    │    │    │    │    │         │    │    │    │    │    │    │                   │    │    │    │    │    │                                  │    │    │    │    │    │    │    │    │    │    │    │    │    │         │    │    │    │    │    │    │                   │    │    │    │    │    │                                  │    │    │    │    │    │    │    │    │    │    │    │    │    │         │    │    │    │    │    │    │
q3: ──H──────────────Z────Z────┼────┼────●────●────H────Z────────────────────────Z────Z────Z────Z────Z────Z────Z────┼────┼────┼────┼────┼────┼────┼────●────●────●────●────●────●────●────●────H──────────────Z────Z────┼────┼────●────●────H────Z────────────────────────Z────Z────Z────Z────Z────Z────Z────┼────┼────┼────┼────┼────┼────┼────●────●────●────●────●────●────●────●────H──────────────Z────Z────┼────┼────●────●────H────Z────────────────────────Z────Z────Z────Z────Z────Z────Z────┼────┼────┼────┼────┼────┼────┼────●────●────●────●────●────●────●────●────H──
                               │    │    │    │                                                                     │    │    │    │    │    │    │    │    │    │    │    │    │    │    │                             │    │    │    │                                                                     │    │    │    │    │    │    │    │    │    │    │    │    │    │    │                             │    │    │    │                                                                     │    │    │    │    │    │    │    │    │    │    │    │    │    │    │
q4: ──H────────────────────────Z────Z────Z────Z────H────Z───────────────────────────────────────────────────────────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────H────────────────────────Z────Z────Z────Z────H────Z───────────────────────────────────────────────────────────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────H────────────────────────Z────Z────Z────Z────H────Z───────────────────────────────────────────────────────────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────Z────H──
```

```python
print(sim3.get_qs(True))                          # Print the final state after running the quantum circuit circuit3 in the simulator sim3
```

```text
-0.03590776623212942¦00000⟩
-0.03590776623212939¦00001⟩
-0.03590776623212932¦00010⟩
-0.03590776623212946¦00011⟩
-0.03590776623212935¦00100⟩
0.6932961018664991¦00101⟩
-0.035907766232129434¦00110⟩
-0.03590776623212945¦00111⟩
-0.035907766232129434¦01000⟩
-0.03590776623212945¦01001⟩
-0.03590776623212935¦01010⟩
0.6932961018664991¦01011⟩
-0.03590776623212932¦01100⟩
-0.03590776623212946¦01101⟩
-0.03590776623212939¦01110⟩
-0.03590776623212939¦01111⟩
-0.0359077662321294¦10000⟩
-0.03590776623212941¦10001⟩
-0.035907766232129414¦10010⟩
-0.035907766232129434¦10011⟩
-0.03590776623212944¦10100⟩
-0.035907766232129434¦10101⟩
-0.03590776623212944¦10110⟩
-0.035907766232129434¦10111⟩
-0.03590776623212943¦11000⟩
-0.035907766232129434¦11001⟩
-0.03590776623212943¦11010⟩
-0.035907766232129434¦11011⟩
-0.0359077662321294¦11100⟩
-0.035907766232129434¦11101⟩
-0.035907766232129414¦11110⟩
-0.03590776623212941¦11111⟩
```

It can be seen from the running results that the amplitudes of the $|00101\rangle$ ​​and $|01011\rangle$ states are both 0.6932961018664989, which are extremely large amplitudes compared to other quantum states, that is, if we measure the current state, the target states $|00101\rangle$ ​​and $|01011\rangle$ ​​states will be obtained with a great probability, run the following code to measure:

```python
# pylint: disable=W0104
sim3.reset()                                      # Reset the quantum state maintained by the simulator sim3 so that the initialized quantum state is |00000>

circuit3 += UN(Measure(), circuit3.n_qubits)      # Add a measurement gate to each qubit in the quantum circuit circuit3

result1 = sim3.sampling(circuit3, shots=1000)     # The quantum circuit circuit3 is sampled 1000 times by the simulator sim3
result1                                           # print sampling results
```

```text
shots: 1000
Keys: q4 q3 q2 q1 q0│0.00   0.126       0.251       0.377       0.503       0.629
────────────────────┼───────────┴───────────┴───────────┴───────────┴───────────┴
               00000│▒
                    │
               00001│▒
                    │
               00100│▒
                    │
               00101│▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
                    │
               00110│▒
                    │
               00111│▒
                    │
               01000│▒
                    │
               01001│▒
                    │
               01010│▒
                    │
               01011│▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
                    │
               01100│▒
                    │
               01101│▒
                    │
               01111│▒
                    │
               10000│▒
                    │
               10001│▒
                    │
               10011│▒
                    │
               10100│▒
                    │
               10101│▒
                    │
               10111│▒
                    │
               11000│▒
                    │
               11011│▒
                    │
               11100│▒
                    │
               11101│▒
                    │
               11111│▒
                    │
{'00000': 2, '00001': 2, '00100': 1, '00101': 463, '00110': 2, '00111': 3, '01000': 1,
'01001': 1, '01010': 1, '01011': 503, '01100': 1, '01101': 1, '01111': 1, '10000': 1,
'10001': 1, '10011': 2, '10100': 2, '10101': 2, '10111': 1, '11000': 3, '11011': 1, '11100':
2, '11101': 2, '11111': 1}
```

It can be seen from the running results that 463 of the 1000 samplings have the sampling result of 00101 and 503 samplings have the result of 01011. Convert it to a decimal number and run the following code:

```python
print(int('00101', 2))
print(int('01011', 2))
```

```text
5
11
```

It can be seen from the running results that we successfully search for the $|5\rangle$ and $|11\rangle$ ​​​​​states.

So far, we have introduced the basic principles of Grover search algorithm, and shown how to use MindQuantum to implement the algorithm by two specific small examples! Hurry up and experience the fun of quantum programming!

To find out more about MindQuantum's API, please click: <https://mindspore.cn/mindquantum/>

## References

[1] L. K. Grover, A fast quantum mechanical algorithm for database search[C]// Proceedings of the twenty-eighth annual ACM symposium on Theory of computing. ACM, 1996: 212-219.

[2] G. Brassard, P. Hoyer, M. Mosca, et al. Quantum amplitude amplification and estimation[J]. Contemporary Mathematics, 2002, 305: 53-74.
